<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Input Format</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<p>This vignette provides a basic example of using Bisque to decompose bulk expression. Bisque offers two modes of operation: Reference-based and Marker-based decomposition. We will provide brief examples of both.</p>

<pre><code class="r">library(Biobase)
library(BisqueRNA)
</code></pre>

<h2>Input Format</h2>

<p>Bisque requires expression data in the ExpressionSet format from the Biobase package. </p>

<p>Bulk RNA-seq data can be converted from a matrix (columns are samples, rows are genes) to an ExpressionSet as follows:</p>

<pre><code class="r">bulk.eset &lt;- Biobase::ExpressionSet(assayData = bulk.matrix)
</code></pre>

<p>Single-cell data requires additional information in the ExpressionSet, specificially cell type labels and individual labels. Individual labels indicate which individual each cell originated from. To add this information, Biobase requires it to be stored in a data frame format. Assuming we have character vectors of cell type labels (<code>cell.type.labels</code>) and individual labels (<code>individual.labels</code>), we can convert scRNA-seq data (with counts also in matrix format) as follows:</p>

<pre><code class="r">sample.ids &lt;- colnames(sc.counts.matrix)
# individual.ids and cell.types should be in the same order as in sample.ids
sc.pheno &lt;- data.frame(check.names=F, check.rows=F,
                       stringsAsFactors=F,
                       row.names=sample.ids,
                       SubjectName=individual.labels,
                       cellType=cell.type.labels)
sc.meta &lt;- data.frame(labelDescription=c(&quot;SubjectName&quot;,
                                         &quot;cellType&quot;),
                      row.names=c(&quot;SubjectName&quot;,
                                  &quot;cellType&quot;))
sc.pdata &lt;- new(&quot;AnnotatedDataFrame&quot;,
                data=sc.pheno,
                varMetadata=sc.meta)
sc.eset &lt;- Biobase::ExpressionSet(assayData=sc.counts.matrix,
                                  phenoData=sc.pdata)
</code></pre>

<p>If your single-cell data (from 10x platform) is in a Seurat object with cell type assignments, Bisque includes a function that will automatically convert this object to an ExpressionSet:</p>

<pre><code class="r">sc.eset &lt;- BisqueRNA::SeuratToExpressionSet(seurat.obj, delimiter=&quot;-&quot;, position=2, version=&quot;v3&quot;)
</code></pre>

<p>The delimiter and position arguments describe the barcode format of 10x single-cell data. For example, barcodes of &ldquo;ATCGATCG-1&rdquo; and &ldquo;ATGCAAGT-2&rdquo; have the individual ID in position 2 after splitting by the delimiter &#39;-&#39;. </p>

<p>Here is an example of input single-cell and bulk data for 2 individuals with 10 cells sequenced each:</p>

<pre><code class="r">sampleNames(sc.eset)
</code></pre>

<pre><code>##  [1] &quot;AAAA-1&quot; &quot;TAAA-1&quot; &quot;CAAA-1&quot; &quot;GAAA-1&quot; &quot;ATAA-1&quot; &quot;TTAA-1&quot; &quot;CTAA-1&quot; &quot;GTAA-1&quot;
##  [9] &quot;ACAA-1&quot; &quot;TCAA-1&quot; &quot;AAAA-2&quot; &quot;TAAA-2&quot; &quot;CAAA-2&quot; &quot;GAAA-2&quot; &quot;ATAA-2&quot; &quot;TTAA-2&quot;
## [17] &quot;CTAA-2&quot; &quot;GTAA-2&quot; &quot;ACAA-2&quot; &quot;TCAA-2&quot;
</code></pre>

<pre><code class="r">sc.eset$SubjectName
</code></pre>

<pre><code>##  [1] &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;1&quot; &quot;2&quot; &quot;2&quot; &quot;2&quot; &quot;2&quot; &quot;2&quot; &quot;2&quot; &quot;2&quot; &quot;2&quot; &quot;2&quot;
## [20] &quot;2&quot;
</code></pre>

<pre><code class="r">sc.eset$cellType
</code></pre>

<pre><code>##  [1] &quot;Neurons&quot;          &quot;Neurons&quot;          &quot;Neurons&quot;          &quot;Neurons&quot;         
##  [5] &quot;Neurons&quot;          &quot;Neurons&quot;          &quot;Neurons&quot;          &quot;Astrocytes&quot;      
##  [9] &quot;Astrocytes&quot;       &quot;Astrocytes&quot;       &quot;Neurons&quot;          &quot;Neurons&quot;         
## [13] &quot;Neurons&quot;          &quot;Neurons&quot;          &quot;Astrocytes&quot;       &quot;Astrocytes&quot;      
## [17] &quot;Astrocytes&quot;       &quot;Astrocytes&quot;       &quot;Oligodendrocytes&quot; &quot;Microglia&quot;
</code></pre>

<pre><code class="r">sampleNames(bulk.eset)
</code></pre>

<pre><code>## [1] &quot;1&quot; &quot;2&quot;
</code></pre>

<p>Note that if you have samples with both single-cell and bulk RNA-seq data, their IDs should be found in both <code>sc.eset$SubjectName</code> and <code>sampleNames(bulk.eset)</code> .</p>

<h2>Reference-based decomposition</h2>

<p>We will use data simulated under a simple model (code for SimulateData() can be found in R/simulation.R).
We simulate single-cell and bulk RNA-seq counts for 10 individuals. We remove 5 individuals from the single-cell data. We will estimate the cell composition for these 5 individuals.</p>

<pre><code class="r">cell.types &lt;- c(&quot;Neurons&quot;, &quot;Astrocytes&quot;, &quot;Oligodendrocytes&quot;, &quot;Microglia&quot;, &quot;Endothelial Cells&quot;)
avg.props &lt;- c(.5, .2, .2, .07, .03)
sim.data &lt;- SimulateData(n.ind=10, n.genes=100, n.cells=500, cell.types=cell.types, avg.props=avg.props)
sc.eset &lt;- sim.data$sc.eset[,sim.data$sc.eset$SubjectName %in% as.character(6:10)]
bulk.eset &lt;- sim.data$bulk.eset
true.props &lt;- sim.data$props
markers &lt;- sim.data$markers
</code></pre>

<p>By default, Bisque uses all genes for decomposition. However, you may supply a list of genes (such as marker genes) to be used with the <code>markers</code> parameter. Also, since we have samples with both bulk and single-cell RNA-seq data, we set the <code>use.overlap</code> parameter to <code>TRUE</code>. If there are no overlapping samples, you can set this parameter to <code>FALSE</code> (we expect performance to be better if overlapping samples are available).</p>

<p>Here&#39;s how to call the reference-based decomposition method:</p>

<pre><code class="r">res &lt;- BisqueRNA::ReferenceBasedDecomposition(bulk.eset, sc.eset, markers=NULL, use.overlap=TRUE)
</code></pre>

<pre><code>## Decomposing into 5 cell types.
</code></pre>

<pre><code>## Found 5 samples with bulk and single-cell expression.
</code></pre>

<pre><code>## Remaining 5 bulk samples will be decomposed.
</code></pre>

<pre><code>## Using 100 genes in both bulk and single-cell expression.
</code></pre>

<pre><code>## Converting single-cell counts to CPM and filtering zero variance genes.
</code></pre>

<pre><code>## Filtered 6 zero variance genes.
</code></pre>

<pre><code>## Converting bulk counts to CPM and filtering unexpressed genes.
</code></pre>

<pre><code>## Filtered 6 unexpressed genes.
</code></pre>

<pre><code>## Generating single-cell based reference from 2500 cells.
</code></pre>

<pre><code>## Learning bulk transformation from overlapping samples.
</code></pre>

<pre><code>## Applying transformation to bulk samples and decomposing.
</code></pre>

<p>A list is returned with decomposition estimates in slot <code>bulk.props</code>.</p>

<pre><code class="r">ref.based.estimates &lt;- res$bulk.props
knitr::kable(ref.based.estimates, digits=2)
</code></pre>

<table><thead>
<tr>
<th align="left"></th>
<th align="right">1</th>
<th align="right">2</th>
<th align="right">3</th>
<th align="right">4</th>
<th align="right">5</th>
</tr>
</thead><tbody>
<tr>
<td align="left">Astrocytes</td>
<td align="right">0.19</td>
<td align="right">0.18</td>
<td align="right">0.19</td>
<td align="right">0.20</td>
<td align="right">0.18</td>
</tr>
<tr>
<td align="left">Endothelial Cells</td>
<td align="right">0.03</td>
<td align="right">0.04</td>
<td align="right">0.03</td>
<td align="right">0.03</td>
<td align="right">0.04</td>
</tr>
<tr>
<td align="left">Microglia</td>
<td align="right">0.09</td>
<td align="right">0.07</td>
<td align="right">0.06</td>
<td align="right">0.08</td>
<td align="right">0.07</td>
</tr>
<tr>
<td align="left">Neurons</td>
<td align="right">0.50</td>
<td align="right">0.54</td>
<td align="right">0.52</td>
<td align="right">0.50</td>
<td align="right">0.51</td>
</tr>
<tr>
<td align="left">Oligodendrocytes</td>
<td align="right">0.20</td>
<td align="right">0.17</td>
<td align="right">0.20</td>
<td align="right">0.20</td>
<td align="right">0.20</td>
</tr>
</tbody></table>

<p>Just to make sure this worked, we can correlate all the estimates with the true proportions.</p>

<pre><code class="r">r &lt;- cor(as.vector(ref.based.estimates), 
         as.vector(true.props[row.names(ref.based.estimates),colnames(ref.based.estimates)]))
knitr::knit_print(sprintf(&quot;R: %f&quot;, r))
</code></pre>

<pre><code>## [1] &quot;R: 0.998478&quot;
</code></pre>

<h2>Marker-based decomposition</h2>

<p>BisqueMarker can provide estimates of relative cell type abundances using only known marker genes when a reference profile is not available. Marker genes are stored in a data frame with columns that specify gene, cluster that the gene is a marker for, and an optional column for weights (typically fold-change). Here&#39;s what this data frame might look like:</p>

<table><thead>
<tr>
<th align="left">gene</th>
<th align="left">cluster</th>
<th align="right">avg_logFC</th>
</tr>
</thead><tbody>
<tr>
<td align="left">Gene 1</td>
<td align="left">Neurons</td>
<td align="right">0.82</td>
</tr>
<tr>
<td align="left">Gene 2</td>
<td align="left">Neurons</td>
<td align="right">0.59</td>
</tr>
<tr>
<td align="left">Gene 3</td>
<td align="left">Astrocytes</td>
<td align="right">0.68</td>
</tr>
<tr>
<td align="left">Gene 4</td>
<td align="left">Oligodendrocytes</td>
<td align="right">0.66</td>
</tr>
<tr>
<td align="left">Gene 5</td>
<td align="left">Microglia</td>
<td align="right">0.71</td>
</tr>
<tr>
<td align="left">Gene 6</td>
<td align="left">Endothelial Cells</td>
<td align="right">0.62</td>
</tr>
</tbody></table>

<p>Here&#39;s how to call the marker-based decomposition method:</p>

<pre><code class="r">res &lt;- BisqueRNA::MarkerBasedDecomposition(bulk.eset, markers, weighted=F)
</code></pre>

<pre><code>## Getting unique markers
</code></pre>

<pre><code>## Estimating proportions for 5 cell types in 10 samples
</code></pre>

<pre><code>## Filtered 6 zero variance genes.
</code></pre>

<pre><code>## Using 6 genes for cell type Astrocytes;
</code></pre>

<pre><code>## 100% of 6 marker genes correlate positively with PC1 for cell type Astrocytes
</code></pre>

<pre><code>## Using 6 genes for cell type Endothelial Cells;
</code></pre>

<pre><code>## 100% of 6 marker genes correlate positively with PC1 for cell type Endothelial Cells
</code></pre>

<pre><code>## Using 5 genes for cell type Microglia;
</code></pre>

<pre><code>## 100% of 5 marker genes correlate positively with PC1 for cell type Microglia
</code></pre>

<pre><code>## Using 15 genes for cell type Neurons;
</code></pre>

<pre><code>## 93% of 15 marker genes correlate positively with PC1 for cell type Neurons
</code></pre>

<pre><code>## Using 10 genes for cell type Oligodendrocytes;
</code></pre>

<pre><code>## 100% of 10 marker genes correlate positively with PC1 for cell type Oligodendrocytes
</code></pre>

<pre><code>## Finished estimating cell type proportions using PCA
</code></pre>

<p>A list is returned with decomposition estimates in slot <code>bulk.props</code>.</p>

<pre><code class="r">marker.based.estimates &lt;- res$bulk.props
knitr::kable(marker.based.estimates, digits = 2)
</code></pre>

<table><thead>
<tr>
<th align="left"></th>
<th align="right">1</th>
<th align="right">2</th>
<th align="right">3</th>
<th align="right">4</th>
<th align="right">5</th>
<th align="right">6</th>
<th align="right">7</th>
<th align="right">8</th>
<th align="right">9</th>
<th align="right">10</th>
</tr>
</thead><tbody>
<tr>
<td align="left">Astrocytes</td>
<td align="right">0.35</td>
<td align="right">-0.93</td>
<td align="right">0.84</td>
<td align="right">3.46</td>
<td align="right">-2.17</td>
<td align="right">-0.62</td>
<td align="right">-0.13</td>
<td align="right">-0.93</td>
<td align="right">2.93</td>
<td align="right">-2.79</td>
</tr>
<tr>
<td align="left">Endothelial Cells</td>
<td align="right">1.78</td>
<td align="right">-0.46</td>
<td align="right">1.52</td>
<td align="right">-0.29</td>
<td align="right">2.55</td>
<td align="right">-0.97</td>
<td align="right">-2.57</td>
<td align="right">0.05</td>
<td align="right">-1.71</td>
<td align="right">0.10</td>
</tr>
<tr>
<td align="left">Microglia</td>
<td align="right">1.73</td>
<td align="right">-0.18</td>
<td align="right">-2.01</td>
<td align="right">0.70</td>
<td align="right">0.07</td>
<td align="right">-1.65</td>
<td align="right">2.91</td>
<td align="right">-0.65</td>
<td align="right">1.98</td>
<td align="right">-2.90</td>
</tr>
<tr>
<td align="left">Neurons</td>
<td align="right">-2.99</td>
<td align="right">4.48</td>
<td align="right">1.00</td>
<td align="right">-2.56</td>
<td align="right">-1.55</td>
<td align="right">1.32</td>
<td align="right">1.43</td>
<td align="right">-2.68</td>
<td align="right">0.35</td>
<td align="right">1.20</td>
</tr>
<tr>
<td align="left">Oligodendrocytes</td>
<td align="right">1.71</td>
<td align="right">-3.74</td>
<td align="right">-0.18</td>
<td align="right">-0.53</td>
<td align="right">1.40</td>
<td align="right">0.98</td>
<td align="right">-2.64</td>
<td align="right">3.21</td>
<td align="right">-2.67</td>
<td align="right">2.46</td>
</tr>
</tbody></table>

<p>Note that these estimates are relative within each cell type, so you cannot immediately compare abundance estimates between cell types.</p>

<p>Just to make sure this worked, we can correlate these estimates with the scaled true proportions.</p>

<pre><code class="r">scaled.true.props &lt;- t(scale(t(true.props)))[rownames(marker.based.estimates),]
r &lt;- cor(as.vector(marker.based.estimates),
         as.vector(scaled.true.props))
knitr::knit_print(sprintf(&quot;R: %f&quot;, r))
</code></pre>

<pre><code>## [1] &quot;R: 0.924982&quot;
</code></pre>

</body>

</html>
